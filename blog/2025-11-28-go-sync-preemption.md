# 拒绝“钉子户”：深入解析 Go 的异步抢占机制 (Go 1.14+)
> 2025-11-28 13:58:28

---

在 Go 语言的调度器（GMP）进化史上，**Go 1.14** 是一个巨大的分水岭。在此之前，Go 经常因为某些写得不好的“死循环”代码而遭到诟病。

你是否遇到过这样的场景：写了一个密集的 `for` 循环计算（比如哈希碰撞或数学计算），结果发现程序里的其他协程都不动了，甚至连 GC（垃圾回收）都卡住无法运行？

这就是**CPU 密集型任务对调度器的挑战**。今天，我们继续沿用**“银行柜台模型”**，来看看 Go 是如何解决这个棘手问题的。

---

## 1. 过去的痛点：太礼貌的“协作式调度”

在 Go 1.14 之前，Go 采用的是**协作式调度（Cooperative Scheduling）**。

### 银行场景重现：
* **M (柜员)**：正在窗口（P）处理业务。
* **G (客户)**：正在办理一个超级复杂的业务，比如“手动清点 10 万枚硬币”。
* **协作式的规则**：柜员（M）非常有礼貌。他心里想着：“只有等客户（G）主动停下来喝口水（发生函数调用），或者主动说‘我歇会儿’（`runtime.Gosched()`），我才会叫下一位。”

**尴尬的情况发生了**：
如果这个客户是个“工作狂”，他一直低头数硬币，既不喝水也不抬头（代码中是一个纯粹的 `for` 循环，没有任何函数调用）。
结果就是：**柜员一直被占用，后面排队的客户（其他 G）全都饿死，连打扫卫生的保洁阿姨（GC）都进不来。**

这被称为 **“线程饥饿”** 或 **“STW 延迟”**。

---

## 2. 救星登场：基于信号的异步抢占

为了解决这种“钉子户”行为，Go 1.14 引入了**基于信号的异步抢占（Signal-Based Asynchronous Preemption）**。

这意味着调度器不再“礼貌等待”，而是拥有了**“强制打断”**的能力。

### 新的银行场景：

#### 第一步：大堂经理的巡视 (Sysmon Detection)
Go 的后台监控线程 **Sysmon**（大堂经理）依然在每隔 10ms - 20ms 巡视大厅。

1.  **发现异常**：Sysmon 走到 3 号窗口，发现柜员小王（M）还是在服务同一个客户（G）。
2.  **查看时间**：计时器显示，这个客户已经连续占用了 **10ms**。
3.  **判定**：这是“钉子户”行为！为了公平起见，必须强制换人。

#### 第二步：发送信号 (SIGURG) —— “拍肩膀”
Sysmon 不能直接把柜员小王拽走（这会导致数据错乱），他需要通过一种特殊的机制通知小王。

* **技术动作**：Sysmon 向 M 所在的**操作系统线程**发送一个 **`SIGURG` 信号**。
* **场景类比**：大堂经理走到柜员小王身后，用力**拍了一下他的肩膀**。

> **为什么是 `SIGURG`？**
> 在 Linux 中，`SIGURG` 通常用于网络带外数据通知，极少被用户程序使用。Go 选择它是为了避免与用户可能使用的信号（如 `SIGINT`, `SIGTERM`）冲突。

#### 第三步：操作系统介入与中断 (Context Switch)
这是最神奇的一步。

1.  **暂停手头工作**：操作系统收到信号，强制暂停 M 当前正在执行的指令（正在数的硬币先放下）。
2.  **执行信号处理函数**：操作系统调用 Go 运行时预先注册好的信号处理函数（Signal Handler）。
3.  **植入“安眠药”**：
    * 信号处理函数会修改 M 的执行上下文。它在当前的指令流中，强行插入了一段汇编指令。
    * 这段指令的作用是：**“立即停止当前任务，保存进度，去睡觉。”**



#### 第四步：恢复与切换
1.  M 恢复执行，但它执行的下一条指令不再是数硬币了，而是刚才插入的“安眠药”指令。
2.  **G 被挂起**：客户（G）被迫收拾好刚才数的硬币记录（保存 PC/SP），心不甘情不愿地离开了窗口，去**全局队列**重新排队。
3.  **M 继续干活**：柜员小王（M）终于解脱了，他按响了叫号机，处理下一个排队的客户。

---

## 3. 技术总结：新旧对比

为了更清晰地理解，我们对比一下两种模式：

| 特性 | **旧版 (Go < 1.14) 协作式** | **新版 (Go 1.14+) 异步抢占** |
| :--- | :--- | :--- |
| **触发时机** | 依赖 G 主动配合（如函数调用时检查栈） | **随时触发**（由 Sysmon 定时监控） |
| **解决的问题** | 能够调度一般的并发任务 | **解决了死循环/密集计算导致的饥饿问题** |
| **核心机制** | Stack Check (栈扩容检查点) | **OS Signals (SIGURG)** |
| **柜台类比** | 柜员等客户主动抬头才换人 | **大堂经理拍肩膀，强制换人** |
| **STW 影响** | 可能导致 GC 长时间等待，程序卡顿 | GC 极其流畅，延迟极低 |

---

## 4. 为什么这被称为“异步”？

这里的“异步”是相对于 G 的执行流而言的。

* **同步抢占（旧版）**：抢占点是编译器安插在函数入口的，G 运行到那里才会触发，G 是“知情”且“配合”的。
* **异步抢占（新版）**：信号随时可能到来，G 根本不知道自己什么时候会被打断，它是**被动**的。

## 5. 结语

Go 的 GMP 模型从早期的简单调度，进化到现在的**信号级抢占**，体现了 Go 团队对低延迟和高并发极致的追求。

下次当你看到 CPU 即使在满负荷跑死循环，其他的 Web 请求依然能秒级响应时，请记得：**那是 Sysmon 正在后台默默地“拍肩膀”，维持着整个系统的公平与秩序。**